/*
 * generated by Xtext 2.26.0.M1
 */
package org.eclipse.viatra.solver.language.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.viatra.solver.language.model.problem.Argument;
import org.eclipse.viatra.solver.language.model.problem.Assertion;
import org.eclipse.viatra.solver.language.model.problem.Atom;
import org.eclipse.viatra.solver.language.model.problem.ClassDeclaration;
import org.eclipse.viatra.solver.language.model.problem.Conjunction;
import org.eclipse.viatra.solver.language.model.problem.ExactMultiplicity;
import org.eclipse.viatra.solver.language.model.problem.NegativeLiteral;
import org.eclipse.viatra.solver.language.model.problem.PredicateDefinition;
import org.eclipse.viatra.solver.language.model.problem.Problem;
import org.eclipse.viatra.solver.language.model.problem.ProblemPackage;
import org.eclipse.viatra.solver.language.model.problem.RangeMultiplicity;
import org.eclipse.viatra.solver.language.model.problem.ReferenceDeclaration;
import org.eclipse.viatra.solver.language.model.problem.ScopeDeclaration;
import org.eclipse.viatra.solver.language.model.problem.TypeScope;
import org.eclipse.viatra.solver.language.model.problem.UnboundedMultiplicity;
import org.eclipse.viatra.solver.language.services.ProblemGrammarAccess;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ProblemSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ProblemGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ProblemPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ProblemPackage.ARGUMENT:
				sequence_Argument(context, (Argument) semanticObject); 
				return; 
			case ProblemPackage.ASSERTION:
				sequence_Assertion(context, (Assertion) semanticObject); 
				return; 
			case ProblemPackage.ATOM:
				sequence_Atom(context, (Atom) semanticObject); 
				return; 
			case ProblemPackage.CLASS_DECLARATION:
				sequence_ClassDeclaration(context, (ClassDeclaration) semanticObject); 
				return; 
			case ProblemPackage.CONJUNCTION:
				sequence_Conjunction(context, (Conjunction) semanticObject); 
				return; 
			case ProblemPackage.EXACT_MULTIPLICITY:
				sequence_ExactMultiplicity(context, (ExactMultiplicity) semanticObject); 
				return; 
			case ProblemPackage.NEGATIVE_LITERAL:
				sequence_NegativeLiteral(context, (NegativeLiteral) semanticObject); 
				return; 
			case ProblemPackage.PARAMETER:
				sequence_Parameter(context, (org.eclipse.viatra.solver.language.model.problem.Parameter) semanticObject); 
				return; 
			case ProblemPackage.PREDICATE_DEFINITION:
				sequence_PredicateDefinition(context, (PredicateDefinition) semanticObject); 
				return; 
			case ProblemPackage.PROBLEM:
				sequence_Problem(context, (Problem) semanticObject); 
				return; 
			case ProblemPackage.RANGE_MULTIPLICITY:
				sequence_RangeMultiplicity(context, (RangeMultiplicity) semanticObject); 
				return; 
			case ProblemPackage.REFERENCE_DECLARATION:
				sequence_ReferenceDeclaration(context, (ReferenceDeclaration) semanticObject); 
				return; 
			case ProblemPackage.SCOPE_DECLARATION:
				sequence_ScopeDeclaration(context, (ScopeDeclaration) semanticObject); 
				return; 
			case ProblemPackage.TYPE_SCOPE:
				sequence_TypeScope(context, (TypeScope) semanticObject); 
				return; 
			case ProblemPackage.UNBOUNDED_MULTIPLICITY:
				sequence_UnboundedMultiplicity(context, (UnboundedMultiplicity) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Argument returns Argument
	 *
	 * Constraint:
	 *     variable=[Variable|ID]
	 */
	protected void sequence_Argument(ISerializationContext context, Argument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProblemPackage.Literals.ARGUMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProblemPackage.Literals.ARGUMENT__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArgumentAccess().getVariableVariableIDTerminalRuleCall_0_1(), semanticObject.eGet(ProblemPackage.Literals.ARGUMENT__VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Assertion
	 *     Assertion returns Assertion
	 *
	 * Constraint:
	 *     (
	 *         (relation=[Relation|QualifiedName] (arguments+=[Node|QualifiedName] arguments+=[Node|QualifiedName]*)? value=LogicValue) | 
	 *         (value=ShortLogicValue? relation=[Relation|QualifiedName] (arguments+=[Node|QualifiedName] arguments+=[Node|QualifiedName]*)?)
	 *     )
	 */
	protected void sequence_Assertion(ISerializationContext context, Assertion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns Atom
	 *     Atom returns Atom
	 *
	 * Constraint:
	 *     (relation=[Relation|QualifiedName] transitiveClosure?='+'? (arguments+=Argument arguments+=Argument*)?)
	 */
	protected void sequence_Atom(ISerializationContext context, Atom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ClassDeclaration
	 *     ClassDeclaration returns ClassDeclaration
	 *
	 * Constraint:
	 *     (
	 *         abstract?='abstract'? 
	 *         name=ID 
	 *         (superTypes+=[ClassDeclaration|QualifiedName] superTypes+=[ClassDeclaration|QualifiedName]*)? 
	 *         referenceDeclarations+=ReferenceDeclaration*
	 *     )
	 */
	protected void sequence_ClassDeclaration(ISerializationContext context, ClassDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Conjunction returns Conjunction
	 *
	 * Constraint:
	 *     (literals+=Literal literals+=Literal*)
	 */
	protected void sequence_Conjunction(ISerializationContext context, Conjunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Multiplicity returns ExactMultiplicity
	 *     DefiniteMultiplicity returns ExactMultiplicity
	 *     ExactMultiplicity returns ExactMultiplicity
	 *
	 * Constraint:
	 *     exactValue=INT
	 */
	protected void sequence_ExactMultiplicity(ISerializationContext context, ExactMultiplicity semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProblemPackage.Literals.EXACT_MULTIPLICITY__EXACT_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProblemPackage.Literals.EXACT_MULTIPLICITY__EXACT_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExactMultiplicityAccess().getExactValueINTTerminalRuleCall_0(), semanticObject.getExactValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns NegativeLiteral
	 *     NegativeLiteral returns NegativeLiteral
	 *
	 * Constraint:
	 *     atom=Atom
	 */
	protected void sequence_NegativeLiteral(ISerializationContext context, NegativeLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProblemPackage.Literals.NEGATIVE_LITERAL__ATOM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProblemPackage.Literals.NEGATIVE_LITERAL__ATOM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNegativeLiteralAccess().getAtomAtomParserRuleCall_1_0(), semanticObject.getAtom());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (parameterType=[ClassDeclaration|ID] name=ID)
	 */
	protected void sequence_Parameter(ISerializationContext context, org.eclipse.viatra.solver.language.model.problem.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProblemPackage.Literals.PARAMETER__PARAMETER_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProblemPackage.Literals.PARAMETER__PARAMETER_TYPE));
			if (transientValues.isValueTransient(semanticObject, ProblemPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProblemPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getParameterTypeClassDeclarationIDTerminalRuleCall_0_0_1(), semanticObject.eGet(ProblemPackage.Literals.PARAMETER__PARAMETER_TYPE, false));
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PredicateDefinition
	 *     PredicateDefinition returns PredicateDefinition
	 *
	 * Constraint:
	 *     (error?='error'? name=ID (parameters+=Parameter parameters+=Parameter*)? (bodies+=Conjunction bodies+=Conjunction*)?)
	 */
	protected void sequence_PredicateDefinition(ISerializationContext context, PredicateDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Problem returns Problem
	 *
	 * Constraint:
	 *     ((name=ID statements+=Statement+) | statements+=Statement+)?
	 */
	protected void sequence_Problem(ISerializationContext context, Problem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Multiplicity returns RangeMultiplicity
	 *     DefiniteMultiplicity returns RangeMultiplicity
	 *     RangeMultiplicity returns RangeMultiplicity
	 *
	 * Constraint:
	 *     (lowerBound=INT upperBound=UpperBound)
	 */
	protected void sequence_RangeMultiplicity(ISerializationContext context, RangeMultiplicity semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ProblemPackage.Literals.RANGE_MULTIPLICITY__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProblemPackage.Literals.RANGE_MULTIPLICITY__LOWER_BOUND));
			if (transientValues.isValueTransient(semanticObject, ProblemPackage.Literals.RANGE_MULTIPLICITY__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ProblemPackage.Literals.RANGE_MULTIPLICITY__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeMultiplicityAccess().getLowerBoundINTTerminalRuleCall_0_0(), semanticObject.getLowerBound());
		feeder.accept(grammarAccess.getRangeMultiplicityAccess().getUpperBoundUpperBoundParserRuleCall_2_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ReferenceDeclaration returns ReferenceDeclaration
	 *
	 * Constraint:
	 *     (
	 *         containment?='contains'? 
	 *         referenceType=[ClassDeclaration|QualifiedName] 
	 *         multiplicity=Multiplicity? 
	 *         name=ID 
	 *         opposite=[ReferenceDeclaration|QualifiedName]?
	 *     )
	 */
	protected void sequence_ReferenceDeclaration(ISerializationContext context, ReferenceDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ScopeDeclaration
	 *     ScopeDeclaration returns ScopeDeclaration
	 *
	 * Constraint:
	 *     (typeScopes+=TypeScope typeScopes+=TypeScope*)
	 */
	protected void sequence_ScopeDeclaration(ISerializationContext context, ScopeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeScope returns TypeScope
	 *
	 * Constraint:
	 *     (targetType=[ClassDeclaration|ID] increment?='+='? multiplicity=DefiniteMultiplicity)
	 */
	protected void sequence_TypeScope(ISerializationContext context, TypeScope semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Multiplicity returns UnboundedMultiplicity
	 *     UnboundedMultiplicity returns UnboundedMultiplicity
	 *
	 * Constraint:
	 *     {UnboundedMultiplicity}
	 */
	protected void sequence_UnboundedMultiplicity(ISerializationContext context, UnboundedMultiplicity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
